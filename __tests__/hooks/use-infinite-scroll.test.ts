/**\n * @jest-environment jsdom\n */\n\nimport { renderHook, act } from '@testing-library/react'\nimport { useInfiniteScroll } from '@/hooks/use-infinite-scroll'\n\n// Mock IntersectionObserver\nclass MockIntersectionObserver {\n  callback: IntersectionObserverCallback\n  options: IntersectionObserverInit\n  elements: Element[] = []\n\n  constructor(callback: IntersectionObserverCallback, options: IntersectionObserverInit = {}) {\n    this.callback = callback\n    this.options = options\n  }\n\n  observe(element: Element) {\n    this.elements.push(element)\n  }\n\n  unobserve(element: Element) {\n    this.elements = this.elements.filter(el => el !== element)\n  }\n\n  disconnect() {\n    this.elements = []\n  }\n\n  // Helper method to simulate intersection\n  simulate(isIntersecting: boolean) {\n    const entries: IntersectionObserverEntry[] = this.elements.map(element => ({\n      target: element,\n      isIntersecting,\n      intersectionRatio: isIntersecting ? 1 : 0,\n      boundingClientRect: element.getBoundingClientRect(),\n      intersectionRect: element.getBoundingClientRect(),\n      rootBounds: null,\n      time: Date.now(),\n    }))\n    this.callback(entries, this)\n  }\n}\n\n// Global mock setup\nconst mockObserver = new MockIntersectionObserver(() => {})\nglobal.IntersectionObserver = jest.fn().mockImplementation((callback, options) => {\n  const observer = new MockIntersectionObserver(callback, options)\n  return observer\n})\n\n// Mock timers\njest.useFakeTimers()\n\ndescribe('useInfiniteScroll', () => {\n  const mockOnLoadMore = jest.fn()\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n    jest.clearAllTimers()\n  })\n\n  afterEach(() => {\n    jest.runOnlyPendingTimers()\n  })\n\n  it('should create an observer with correct options', () => {\n    const { result } = renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: true,\n      isLoading: false,\n      threshold: 0.5,\n      rootMargin: '100px',\n    }))\n\n    expect(IntersectionObserver).toHaveBeenCalledWith(\n      expect.any(Function),\n      {\n        threshold: 0.5,\n        rootMargin: '100px',\n        root: null,\n      }\n    )\n  })\n\n  it('should use default values from config when no options provided', () => {\n    renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: true,\n      isLoading: false,\n    }))\n\n    expect(IntersectionObserver).toHaveBeenCalledWith(\n      expect.any(Function),\n      {\n        threshold: 0.3, // INFINITE_SCROLL.THRESHOLD\n        rootMargin: '200px', // INFINITE_SCROLL.ROOT_MARGIN\n        root: null,\n      }\n    )\n  })\n\n  it('should call onLoadMore when element intersects and conditions are met', () => {\n    const { result } = renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: true,\n      isLoading: false,\n      debounceMs: 0, // Disable debounce for testing\n    }))\n\n    // Simulate element being observed\n    const mockElement = document.createElement('div')\n    Object.defineProperty(result.current, 'current', {\n      value: mockElement,\n    })\n\n    // Get the observer instance\n    const observerInstance = (IntersectionObserver as jest.Mock).mock.results[0].value\n\n    act(() => {\n      observerInstance.simulate(true)\n    })\n\n    expect(mockOnLoadMore).toHaveBeenCalledTimes(1)\n  })\n\n  it('should not call onLoadMore when isLoading is true', () => {\n    const { result } = renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: true,\n      isLoading: true,\n      debounceMs: 0,\n    }))\n\n    const observerInstance = (IntersectionObserver as jest.Mock).mock.results[0].value\n\n    act(() => {\n      observerInstance.simulate(true)\n    })\n\n    expect(mockOnLoadMore).not.toHaveBeenCalled()\n  })\n\n  it('should not call onLoadMore when hasMore is false', () => {\n    const { result } = renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: false,\n      isLoading: false,\n      debounceMs: 0,\n    }))\n\n    const observerInstance = (IntersectionObserver as jest.Mock).mock.results[0].value\n\n    act(() => {\n      observerInstance.simulate(true)\n    })\n\n    expect(mockOnLoadMore).not.toHaveBeenCalled()\n  })\n\n  it('should debounce multiple intersection calls', () => {\n    const { result } = renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: true,\n      isLoading: false,\n      debounceMs: 100,\n    }))\n\n    const observerInstance = (IntersectionObserver as jest.Mock).mock.results[0].value\n\n    // Simulate multiple rapid intersections\n    act(() => {\n      observerInstance.simulate(true)\n      observerInstance.simulate(true)\n      observerInstance.simulate(true)\n    })\n\n    // Should not be called yet due to debounce\n    expect(mockOnLoadMore).not.toHaveBeenCalled()\n\n    // Fast forward time\n    act(() => {\n      jest.advanceTimersByTime(100)\n    })\n\n    // Should be called only once after debounce\n    expect(mockOnLoadMore).toHaveBeenCalledTimes(1)\n  })\n\n  it('should cleanup observer on unmount', () => {\n    const { unmount } = renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: true,\n      isLoading: false,\n    }))\n\n    const observerInstance = (IntersectionObserver as jest.Mock).mock.results[0].value\n    const disconnectSpy = jest.spyOn(observerInstance, 'disconnect')\n\n    unmount()\n\n    expect(disconnectSpy).toHaveBeenCalled()\n  })\n\n  it('should clear timeout on unmount', () => {\n    const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout')\n    \n    const { unmount } = renderHook(() => useInfiniteScroll({\n      onLoadMore: mockOnLoadMore,\n      hasMore: true,\n      isLoading: false,\n      debounceMs: 100,\n    }))\n\n    const observerInstance = (IntersectionObserver as jest.Mock).mock.results[0].value\n\n    act(() => {\n      observerInstance.simulate(true)\n    })\n\n    unmount()\n\n    expect(clearTimeoutSpy).toHaveBeenCalled()\n  })\n\n  it('should handle state changes correctly', () => {\n    let hasMore = true\n    let isLoading = false\n\n    const { rerender } = renderHook(\n      ({ hasMore, isLoading }) => useInfiniteScroll({\n        onLoadMore: mockOnLoadMore,\n        hasMore,\n        isLoading,\n        debounceMs: 0,\n      }),\n      {\n        initialProps: { hasMore, isLoading }\n      }\n    )\n\n    const observerInstance = (IntersectionObserver as jest.Mock).mock.results[0].value\n\n    // First intersection should work\n    act(() => {\n      observerInstance.simulate(true)\n    })\n    expect(mockOnLoadMore).toHaveBeenCalledTimes(1)\n\n    // Update state to loading\n    isLoading = true\n    rerender({ hasMore, isLoading })\n\n    // Should not call onLoadMore when loading\n    act(() => {\n      observerInstance.simulate(true)\n    })\n    expect(mockOnLoadMore).toHaveBeenCalledTimes(1) // Still 1\n\n    // Update state to no more\n    isLoading = false\n    hasMore = false\n    rerender({ hasMore, isLoading })\n\n    // Should not call onLoadMore when no more\n    act(() => {\n      observerInstance.simulate(true)\n    })\n    expect(mockOnLoadMore).toHaveBeenCalledTimes(1) // Still 1\n  })\n})
